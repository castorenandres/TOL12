# # import
import turtle
from collections import deque
from typing import Type
from MemoryVM import GlobalMemory
from MemoryVM import LocalMemory
class VirtualMachine:
    memoryG = GlobalMemory()
    constantTable = {}
    funcTable = {}
    instruction = 1
    prevInstruction = deque()
    prevMemoryL = deque['LocalMemory']()
    funcName = ''
    prevFunc = deque()
    # quadruples parts
    op = 0
    right = 0
    left = 0
    res = 0
    trt = turtle.Turtle()

    # Return the program's name, which holds global variables and constants.
    def getProgramsName(self):
        for key, value in self.funcTable.items():
            if "varT" in value:
                return key


    # Iterate through funcTable dictionary by variable to add each variable to memory.
    def setGlobalVariables(self):
        programName = self.getProgramsName()
        varTable = self.funcTable[programName]["varT"]
        for variable in varTable:
            self.memoryG.setGlobalVariables(varTable[variable]["dir"])

    # Iterate through constantTable dictionary by constant to add each constant to memory.
    def setConstantVariables(self):
        for constant in self.constantTable:
            dirC = self.constantTable[constant]
            self.memoryG.setConstants(dirC, constant)

    # Returns the quadruple parts.    
    def breakQuadrupleParts(self, quadruple, instruction):
        op = quadruple[instruction]["op"]
        left = quadruple[instruction]["left"]
        right = quadruple[instruction]["right"]
        res = quadruple[instruction]["res"]

        return op, left, right, res

    # Returns the size parts.
    def breakFunctionSizes(self, name):
        if name in self.funcTable:
            size = self.funcTable[name]["size"]
            parami = size["parami"]
            paramf = size["paramf"]
            vari = size["vari"]
            varf = size["varf"]
            tempi = size["tempi"]
            tempf = size["tempf"]
        else:
            raise NameError("Function name does not exists")

        return parami, paramf, vari, varf, tempi, tempf

    # Returns function address.
    def getFuncDir(self, name):
        if name in self.funcTable:
            return self.funcTable[name]["dir"]

    def getGlobalVariableDir(self, name):
        programName = self.getProgramsName()
        if name in self.funcTable[programName]["varT"]:
            return self.funcTable[programName]["varT"][name]["dir"]

    # Main function of the virtual machine, runs the intermidiate code generated by the parser.
    def startProgram(self, quadruples, funcTable, constantTable):
        print("---------------------------------------------------------------")
        self.funcTable = funcTable
        self.constantTable = constantTable
        self.setGlobalVariables()
        self.setConstantVariables()
        # print(funcTable, '\n')
        # print(constantTable, '\n')
        # print(quadruples, '\n')
        # self.memoryG.show()

        while self.instruction < len(quadruples):
            self.op, self.left, self.right, self.res = self.breakQuadrupleParts(quadruples, self.instruction)

            # arithmetic expressions
            if self.op == 1: # +
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    result = leftSide + rightSide
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    result = leftSide + rightSide
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 2: # -
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    result = leftSide - rightSide
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    result = leftSide - rightSide
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 3: # *
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    result = leftSide * rightSide
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    result = leftSide * rightSide
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 4: # /
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    result = leftSide / rightSide
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    result = leftSide / rightSide
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 5: # ==
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    if leftSide == rightSide:
                        result = 1
                    else:
                        result = 0
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    if leftSide == rightSide:
                        result = 1
                    else:
                        result = 0
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 6: # !=
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    if leftSide != rightSide:
                        result = 1
                    else:
                        result = 0
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    if leftSide != rightSide:
                        result = 1
                    else:
                        result = 0
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 7: # >
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    if leftSide > rightSide:
                        result = 1
                    else:
                        result = 0
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    if leftSide > rightSide:
                        result = 1
                    else:
                        result = 0
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 8: # <
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    if leftSide < rightSide:
                        result = 1
                    else:
                        result = 0
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    if leftSide < rightSide:
                        result = 1
                    else:
                        result = 0
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 9: # &
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    if leftSide and rightSide:
                        result = 1
                    else:
                        result = 0
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    if leftSide and rightSide:
                        result = 1
                    else:
                        result = 0
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 10: # |
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                else:
                    leftSide = self.memoryG.getValue(self.left)

                if self.right >= 5000 and self.right < 9000:
                    rightSide = memoryL.getLocalValue(self.right)
                    if leftSide or rightSide:
                        result = 1
                    else:
                        result = 0
                    memoryL.updateLocalMemory(self.res, result)
                else:
                    rightSide = self.memoryG.getValue(self.right)
                    if leftSide or rightSide:
                        result = 1
                    else:
                        result = 0
                    self.memoryG.setTempVariables(self.res, result)
            elif self.op == 11: # =
                if self.left >= 5000 and self.left < 9000:
                    # local variable
                    leftSide = memoryL.getLocalValue(self.left)
                    memoryL.updateLocalMemory(self.res, leftSide)
                else:
                    leftSide = self.memoryG.getValue(self.left)
                    self.memoryG.updateMemory(self.res, leftSide)
            
            # Pre-define functions
            # read and write
            elif self.op == 101:
                result = input()

                if "." in result:
                    result = float(result)
                else:
                    result = int(result)

                if self.res >= 5000 and self.res < 9000:
                    # local variable
                    # t_res = getType
                    print("local variable")
                else:
                    t_res = self.memoryG.getType(self.res)
                    if t_res == "int" and type(result) == int:
                        self.memoryG.updateMemory(self.res, result)
                    elif t_res == "float" and type(result) == float:
                        self.memoryG.updateMemory(self.res, result)
                    else:
                        raise TypeError("Input and variable type do not match")

                # self.memoryG.show()
            elif self.op == 102:
                if self.res >= 11000 and self.res < 12000:
                    result = self.memoryG.getValue(self.res)
                    result = result.replace('"', '')
                    result = result.replace("\\n", "\n")
                    print(result, end="")
                else:
                    result = self.memoryG.getValue(self.res)
                    print(result)
            
            # Turtle graphics functions
            elif self.op == 103:
                x = self.memoryG.getValue(self.left)
                y = self.memoryG.getValue(self.right)
                self.trt.setpos(x, y)
            elif self.op == 104:
                radius = self.memoryG.getValue(self.left)
                self.trt.circle(radius)
            elif self.op == 105:
                distance = self.memoryG.getValue(self.left)
                if self.right == "vertical":
                    self.trt.sety(distance)
                else:
                    self.trt.setx(distance)
            elif self.op == 106:
                radius = self.memoryG.getValue(self.left)
                angle = self.memoryG.getValue(self.right)
                self.trt.circle(radius, angle)
            elif self.op == 107:
                self.trt.penup()
            elif self.op == 108:
                self.trt.pendown()
            elif self.op == 109:
                red = self.memoryG.getValue(self.left)
                green = self.memoryG.getValue(self.right)
                blue = self.memoryG.getValue(self.res)
                self.trt.screen.colormode(255)
                self.trt.pencolor(red, green, blue)
            elif self.op == 110:
                width = self.memoryG.getValue(self.left)
                self.trt.width(width)
            elif self.op == 111:
                self.trt.clear()

            # condicionales y ciclos
            elif self.op == 30:
                self.instruction = self.res - 1
            elif self.op == 31:
                if self.memoryG.getValue(self.left) == 0:
                    self.instruction = self.res - 1
            elif self.op == 32:
                if self.memoryG.getValue(self.left) == 1:
                    self.instruction = self.res - 1

            # funciones
            elif self.op == 33: # ERA
                # para recursividad, checar que prevMemoryL este vacio o si tienes funciones dentro
                # checar que se pueda trabajar con dos memorias
                parami, paramf, vari, varf, tempi, tempf = self.breakFunctionSizes(self.res)
                self.funcName = self.res
                memoryL = LocalMemory(parami, paramf, vari, varf, tempi, tempf)
                self.prevInstruction.append(self.instruction)
            elif self.op == 34: # PARAM
                # para recursividad, checar que prevMemoryL este vacio o si tienes funciones dentro
                # checar que se pueda trabajar con dos memorias
                if self.left >= 5000 and self.left < 9000:
                    result = memoryL.getLocalValue(self.left)
                else:
                    result = self.memoryG.getValue(self.left)
                
                memoryL.setParam(result)
                memoryL.show()
            elif self.op == 35: # GOSUB
                funcDir = self.getFuncDir(self.res)
                self.prevInstruction.append(self.instruction)
                self.instruction = funcDir - 1
            elif self.op == 36: # ENDFUNC
                del memoryL
                # si prevMemoryL > 0 entonces pop de prevMemoryL para recursion
                self.instruction = self.prevInstruction.pop()
            elif self.op == 100: # Return
                result = memoryL.getLocalValue(self.res)
                retVariable = self.funcName + "Value"
                retVariableDir = self.getGlobalVariableDir(retVariable)

                self.memoryG.updateMemory(retVariableDir, result)
                


            # print(self.instruction)
            self.instruction = self.instruction + 1
        turtle.done()
        self.memoryG.show()
        # print(quadruples)
